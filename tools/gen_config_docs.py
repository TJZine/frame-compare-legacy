#!/usr/bin/env python3
"""Generate Markdown tables describing configuration defaults."""

from __future__ import annotations

import argparse
import dataclasses
import importlib
import json
import sys
import types as types_module
from dataclasses import MISSING, Field
from enum import Enum
from functools import lru_cache
from pathlib import Path
from typing import Any, Dict, Iterable, List, Literal, Tuple, Union, get_args, get_origin, get_type_hints

PROJECT_ROOT = Path(__file__).resolve().parents[1]


@dataclasses.dataclass(frozen=True)
class SectionSpec:
    key: str
    cls: type[Any]
    heading: str


SECTION_DEFINITIONS: List[Tuple[str, str, str]] = [
    ("analysis", "AnalysisConfig", "Analysis settings"),
    ("audio_alignment", "AudioAlignmentConfig", "Audio alignment"),
    ("screenshots", "ScreenshotConfig", "Screenshot rendering"),
    ("color", "ColorConfig", "Color management"),
    ("slowpics", "SlowpicsConfig", "Slow.pics and metadata automation"),
    ("tmdb", "TMDBConfig", "TMDB lookup"),
    ("report", "ReportConfig", "HTML report viewer"),
    ("runtime", "RuntimeConfig", "Runtime and environment"),
    ("cli", "CLIConfig", "[cli] defaults"),
    ("paths", "PathsConfig", "Paths"),
    ("naming", "NamingConfig", "Naming"),
    ("source", "SourceConfig", "Source"),
    ("overrides", "OverridesConfig", "Overrides (`[overrides]`)"),
]


def generate_markdown() -> str:
    parts: List[str] = [
        "<!-- Generated by tools/gen_config_docs.py; do not edit by hand. -->",
        "# Configuration defaults",
        "",
    ]
    for spec in _get_section_specs():
        parts.append(_render_section(spec.key, spec.cls, spec.heading, level=2))
        parts.append("")
    return "\n".join(parts).strip() + "\n"


@lru_cache(maxsize=1)
def _get_section_specs() -> Tuple[SectionSpec, ...]:
    module = _import_datatypes_module()
    specs: List[SectionSpec] = []
    for key, class_name, heading in SECTION_DEFINITIONS:
        cls = getattr(module, class_name)
        specs.append(SectionSpec(key, cls, heading))
    return tuple(specs)


def _import_datatypes_module():
    if "src.datatypes" in sys.modules:
        return sys.modules["src.datatypes"]
    if str(PROJECT_ROOT) not in sys.path:
        sys.path.insert(0, str(PROJECT_ROOT))
    return importlib.import_module("src.datatypes")


def _render_section(key: str, cls: type[Any], heading: str, *, level: int) -> str:
    path = key
    heading_prefix = "#" * level
    section_title = f"{heading_prefix} {heading}"
    lines: List[str] = [section_title, ""]
    rows, nested = _collect_rows(cls, path)
    lines.extend(_render_table(rows))
    for nested_key, nested_cls in nested:
        lines.append("")
        lines.append(_render_section(
            nested_key,
            nested_cls,
            f"[{nested_key}]",
            level=level + 1,
        ))
    return "\n".join(lines)


def _collect_rows(cls: type[Any], path: str) -> Tuple[List[Tuple[str, str, str]], List[Tuple[str, type[Any]]]]:
    hints = get_type_hints(cls, include_extras=True)
    rows: List[Tuple[str, str, str]] = []
    nested: List[Tuple[str, type[Any]]] = []
    for field in dataclasses.fields(cls):
        field_type = hints.get(field.name, field.type)
        if _is_dataclass_type(field_type):
            nested.append((f"{path}.{field.name}", field_type))
            continue
        default_value = _default_for_field(field)
        if default_value is MISSING:
            continue
        key = f"[{path}].{field.name}"
        rows.append((key, _format_type(field_type), _format_default(default_value)))
    return rows, nested


def _render_table(rows: Iterable[Tuple[str, str, str]]) -> List[str]:
    lines = ["| Key | Type | Default |", "| --- | --- | --- |"]
    for key, type_str, default_str in rows:
        lines.append(f"| `{key}` | {type_str} | `{default_str}` |")
    return lines


def _default_for_field(field: Field[Any]) -> Any:
    if field.default is not MISSING:
        return field.default
    if field.default_factory is not MISSING:  # type: ignore[attr-defined]
        return field.default_factory()  # type: ignore[misc]
    return MISSING


def _format_default(value: Any) -> str:
    if isinstance(value, Enum):
        return json.dumps(value.value)
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (int, float)):
        return str(value)
    if isinstance(value, str):
        return json.dumps(value)
    if isinstance(value, (list, dict)):
        return json.dumps(value, ensure_ascii=False)
    if isinstance(value, set):
        return json.dumps(sorted(list(value)), ensure_ascii=False)
    return json.dumps(value, ensure_ascii=False)


def _format_type(annotation: Any) -> str:
    if annotation is Any:
        return "Any"
    if annotation is type(None):  # noqa: E721 - intentional identity check
        return "null"
    if isinstance(annotation, types_module.UnionType):
        return _format_union(annotation)
    origin = get_origin(annotation)
    if origin is Union:
        return _format_union(annotation)
    if origin is list or origin is List:
        args = get_args(annotation)
        inner = _format_type(args[0]) if args else "Any"
        return f"list[{inner}]"
    if origin is dict or origin is Dict:
        args = get_args(annotation)
        key_type = _format_type(args[0]) if len(args) >= 1 else "Any"
        value_type = _format_type(args[1]) if len(args) >= 2 else "Any"
        return f"dict[{key_type}, {value_type}]"
    if origin is tuple or origin is Tuple:
        args = get_args(annotation)
        inner = ", ".join(_format_type(arg) for arg in args) if args else ""
        return f"tuple[{inner}]" if inner else "tuple"
    if origin is Literal:
        values = "|".join(json.dumps(arg) for arg in get_args(annotation))
        return f"literal({values})"
    if isinstance(annotation, type):
        if issubclass(annotation, Enum):
            options = "|".join(json.dumps(member.value) for member in annotation)
            return f"str ({options})"
        return annotation.__name__
    return str(annotation)


def _format_union(annotation: Any) -> str:
    args = get_args(annotation)
    parts: List[str] = []
    seen: set[str] = set()
    for arg in args:
        part = _format_type(arg)
        if part == "null":
            part = "null"
        if part not in seen:
            seen.add(part)
            parts.append(part)
    return "|".join(parts)


def _is_dataclass_type(annotation: Any) -> bool:
    if isinstance(annotation, type) and dataclasses.is_dataclass(annotation):
        return True
    return False


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    default_out = PROJECT_ROOT / "docs" / "_generated" / "config_tables.md"
    parser.add_argument(
        "--out",
        type=Path,
        default=default_out,
        help="File to write generated Markdown to.",
    )
    parser.add_argument(
        "--check",
        type=Path,
        help="Compare freshly generated output to the provided file and exit non-zero on drift.",
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    content = generate_markdown()
    if args.check:
        existing = args.check.read_text(encoding="utf-8") if args.check.exists() else ""
        if existing != content:
            raise SystemExit("config docs are out of date")
    if args.out and (not args.check or args.out != args.check):
        args.out.parent.mkdir(parents=True, exist_ok=True)
        args.out.write_text(content, encoding="utf-8")


if __name__ == "__main__":
    main()
